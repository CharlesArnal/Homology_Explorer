import os
import copy
import json
import numpy as np
import subprocess
import matplotlib.pyplot as plt
from math import comb
from utilities import read_triang, write_triang, purify_points, purify_triang, points2monomials

from homology_objective_functions import compute_homology

	# TODO copy documents rather than open them and paste the content

class Current_Point():
	def __init__(self, dim, degree,  local_path, current_point_folder):
		"""Stores all the information related to a triangulation and signs distribution

			Can also create a triangulation and its associated info, or complete partial information

			The files are nonexistent at first

			The folder is created here if nonexistent
		"""
			
		"""
			Remarks :
			points2chiro and points2flips need a "seed" file, that must be of the following format :
			[[0, 0, 1], [1, 0, 1], [2, 0, 1], [0, 1, 1], [0, 2, 1], [1, 1, 1]]

			[[2, 1, 0, 5, 4, 3], [4, 5, 2, 3, 0, 1]]

			{{0, 2, 4}}
			(note that the points are in non-homogeneous coordinates with an additional 1 at the end)
			---
			Polymake needs the points (in all_points_file) to be in the following format :
			1 2 0 0
			1 1 1 0
			1 0 2 0
			1 1 0 1
			1 0 0 2
			1 0 1 1
			(the points are in homogeneous coordinates with an additional 1 at the start)
		"""
		self.dim = dim
		self.degree = degree
		self.local_path = local_path
		self.current_point_folder = current_point_folder

		# creates the folder if it does not exist
		if not os.path.exists(os.path.join(local_path,current_point_folder)):
			os.mkdir(os.path.join(local_path,current_point_folder))
			
		self.chiro_file = os.path.join(local_path,current_point_folder,"chiro.dat")
		self.triang_file = os.path.join(local_path,current_point_folder,"triang.dat")
		self.all_points_file = os.path.join(local_path,current_point_folder,"all_points.dat")
		self.signs_file = os.path.join(local_path,current_point_folder,"signs.dat")
		self.symmetries_file = os.path.join(local_path,current_point_folder,"symmetries.dat")
		self.current_points_indices_file = os.path.join(local_path,current_point_folder,"current_points_indices.dat")
		self.flips_file = os.path.join(local_path,current_point_folder,"flips.dat")

		self.list_of_files_names = {"chiro.dat":self.chiro_file, "triang.dat":self.triang_file, "all_points.dat":self.all_points_file, \
									"signs.dat":self.signs_file, "symmetries.dat":self.symmetries_file, "current_points_indices.dat":self.current_points_indices_file, "flips.dat":self.flips_file}

	def create_all_points_file(self, verbose = False):
		""" For a simplex in self.dim and self.degree

			Nothing is needed for this method

			The points are in the polymake-compatible format 
			1 2 0 0
			1 1 1 0
			1 0 2 0
			1 1 0 1
			1 0 0 2
			1 0 1 1

		"""
		print("Creating the list of all the points in the set")
		vertices = [[0]*self.dim]
		# List all the non-homogeneous vertices of the simplex
		# 2 0
		for dim_considered in range(self.dim):
			new_vertices = []
			for vertex in vertices:
				for t in range(1,self.degree-sum(vertex)+1):
					new_vertex = copy.copy(vertex)
					new_vertex[dim_considered] = t
					if self.degree-sum(new_vertex)>=0:
						new_vertices += [new_vertex]
			vertices+=new_vertices
		# homogenize them and add a 1 at the start: 0 1 -> 1 1 0 1 (for degree 2)
		for index, vertex in enumerate(vertices) :
			vertices[index] = [1] + [self.degree - sum(vertex)] + vertex 
		with open(self.all_points_file,"w") as t:
			np.savetxt(t,np.array(vertices),fmt='%d')
		if verbose:
			print("Vertices: ")
			print(vertices)

	def create_symmetries_file(self, verbose = False):
		"""Checks if the symmetries_file already exists, computes it if it doesn't (computes it any way if force_recompute == True) 

			self.all_points_file must exist

			The symmetries are computed assuming we are in the case of a standard simplex
		"""
		print("Computing the symmetries of the points set")
		if not os.path.exists(self.all_points_file):
			print("Error : all_points_file must exist")
		with open(self.all_points_file, "r") as f:
			# the vertices are in format 1 2 0 0
			vertices = np.loadtxt(f,dtype= int).tolist()
			# We need them in format 0 0 (non-homogenous coordinates without the 1 at the start)
			vertices  = [vertex[2:] for vertex in vertices]
		# Describe (through their action on the vertices) a family of generators of the group of symmetries defined by the permutations of axes
		# They are generated by the permutations (1,2), (1,3), ..., (1,n) 
		# (where 1 corresponds to (0,0,...,0), 2 to (d,0,...,0), etc.)	
		permutation_generators =  []
		for considered_dim in range(0, self.dim):
			# consider the permutation (1,dim+1) of (0,...,0) and (0,...,d,...,0)
			permuted_vertices = []
			for vertex in vertices:
				permuted_vertex = copy.copy(vertex)
				permuted_vertex[considered_dim] = self.degree- sum(permuted_vertex)
				permuted_vertices.append(permuted_vertex)
			permutation = []
			for vertex in permuted_vertices:
				permutation.append(vertices.index(vertex))
			permutation_generators.append(permutation)
		
		with open(self.symmetries_file, 'w') as f:
			json.dump(permutation_generators,f)
		if verbose:
			print("Symmetries :")
			print(permutation_generators)

	def create_trivial_triang_file(self, verbose = False):
		"""Creates a trivial triangulation (the whole simplex) in format {{0, 2, 4}}

			self.all_points_file must exist		
		"""
		print("Creating a trivial triangulation")
		if not os.path.exists(self.all_points_file):
			print("Error : all_points_file must exist")
		large_simplex = [0]
		with open(self.all_points_file, "r") as f:
			# the vertices are in format 1 2 0 0
			vertices = np.loadtxt(f,dtype= int).tolist()
			# We need them in format 0 0 (non-homogenous coordinates without the 1 at the start)
			vertices  = [vertex[2:] for vertex in vertices]
		for considered_dim in range(self.dim):
			index = vertices.index([0]*considered_dim+[self.degree]+[0]*(self.dim-considered_dim-1))
			large_simplex.append(index)
		trivial_triangulation = [large_simplex]
		with open(self.triang_file, 'w') as f:
			my_string = json.dumps(trivial_triangulation).replace(']', '}').replace('[', '{')
			f.write(my_string)
		if verbose:
			print("Triangulation :")
			print(my_string)
	

	def create_seed_file(self, seed_file_name = "seed.dat", verbose = False):
		"""Computes and stores a seed_file in the current_point_folder (needed to compute the chirotope and the flips)

			triang_file, all_points_file and symmetries_file are needed to compute seed_file
		"""
		if verbose:
			print("Creating a seed file for topcom")
		if not (os.path.exists(self.all_points_file) and os.path.exists(self.triang_file) and os.path.exists(self.symmetries_file)):
			print("Error : all_points_file, triang_file and symmetries_file must exist")
		with open(self.all_points_file, "r") as f:
			# the vertices are in format 1 2 0 0
			vertices = np.loadtxt(f,dtype= int).tolist()
			# We need them in format 0 0 1 (non-homogenous coordinates without the 1 at the start and with a 1 at the end)
			vertices  = [vertex[2:] + [1] for vertex in vertices]
		with open(self.triang_file,"r") as f:
			triang = f.readlines()[0]
		with open(self.symmetries_file,"r") as f:
			symmetries = f.readlines()[0]
		with open(os.path.join(self.local_path,self.current_point_folder,seed_file_name),"w") as f:
			f.write(str(vertices))
			f.write("\n\n")
			f.write(symmetries)
			f.write("\n\n")
			f.write(triang)


	def delete_seed_file(self, seed_file_name = "seed.dat", verbose = False):
		"""Deletes the seed_file from current_point_folder (it is only useful for the chirotope and the flips)"""
		if verbose :
			print("Deleting the seed file")
		os.remove(os.path.join(self.local_path, self.current_point_folder, seed_file_name))


	def create_current_points_indices_file(self, verbose = False):
		"""Computes the current_points_indices_file from triang_file"""
		print("Creating the current points indices file")
		if not os.path.exists(self.triang_file) :
			print("Error : triang_file  must exist")
		with open(self.triang_file,"r") as f:
			triang = f.readlines()[0]
		with open(self.current_points_indices_file,"w") as i:
			current_indices = {int(index) for index in triang.replace("\n","").replace("{","").replace("}","").split(",")}
			i.write(str(current_indices))
		if verbose:
			print("Indices of points featuring in the current triangulation :  ")
			print(str(current_indices))


	def create_flips_file(self, force_recompute = False):
		"""Checks if the flips_file already exists, computes it if it doesn't (computes it any way if force_recompute == True)

			Can be slightly costly
		"""
		print("Computing the flips file")
		recompute = False
		if not os.path.exists(self.flips_file) or force_recompute:
			recompute = True
		if recompute:
			seed_file_name = "seed.dat"
			self.create_seed_file(seed_file_name)
			topcom_errors_file_path = os.path.join(self.local_path, self.current_point_folder, "topcom_errors.dat")
			os.system("points2flips < "+ os.path.join(self.local_path, self.current_point_folder, seed_file_name) +" 1> "+ self.flips_file  +" 2> "+topcom_errors_file_path)
			self.delete_seed_file(seed_file_name)
		else :
			print("The flips file already exists")

	def create_chiro_file(self, force_recompute = False):
		"""Checks if the chiro_file already exists, computes it if it doesn't (computes it any way if force_recompute == True) 

			Can be VERY costly (>10mn)
		"""
		print("Computing the chirotope file")
		recompute = False
		if not os.path.exists(self.chiro_file) or force_recompute:
			recompute = True
		if recompute:
			seed_file_name = "seed.dat"
			self.create_seed_file(seed_file_name)
			topcom_errors_file_path = os.path.join(self.local_path, self.current_point_folder, "topcom_errors.dat")
			os.system("points2chiro < "+ os.path.join(self.local_path, self.current_point_folder, seed_file_name) +" 1> "+ self.chiro_file  +" 2> "+topcom_errors_file_path)
			self.delete_seed_file(seed_file_name)
			print("Chirotope computed")
		else :
			print("The chirotope file already exists")

	def create_random_signs_file(self, verbose = False):
		"""Creates a random distribution of signs in signs_file (with the correct number of signs)

			self.triang_file must exist
		"""
		print("Creating a random signs distribution of the appropriate length")
		if not os.path.exists(self.triang_file) :
			print("Error : triang_file  must exist")
		with open(self.triang_file,"r") as f:
			triang = f.readlines()[0]
			current_indices = {int(index) for index in triang.replace("\n","").replace("{","").replace("}","").split(",")}
		with open(self.signs_file,"w") as f:
			n_points = len(current_indices)
			signs = np.random.randint(2, size = (1,n_points))
			np.savetxt(f,signs,fmt='%d')
		if verbose:
			print("Signs :")
			print(" ".join([str(sign) for sign in signs.tolist()[0]]))

	def standard_initialization(self, verbose = False):
		"""Creates a trivial triangulation in self.dim and self.degree and all the associated files needed for a walk on the graph of triangulations """
		print(f"Creating a trivial triangulation in dimension {self.dim} and degree {self.degree} and all associated files")
		self.create_all_points_file(verbose)
		self.create_symmetries_file(verbose)
		self.create_trivial_triang_file(verbose)
		self.create_current_points_indices_file(verbose)
		self.create_flips_file(force_recompute= True)
		self.create_chiro_file(force_recompute=False)	# Careful
		self.create_random_signs_file(verbose)


	def Harnack_curve_initialization(self, verbose = True):
		"""Creates a Harnack triangulation in dimension 2 and self.degree and all the associated files needed for a walk on the grapoh of triangulations

			The signs are random
		 """
		print(f"Creating a Harnack triangulation for a curve of degree {self.degree} and all associated files")
		if self.dim != 2:
			print("Harnack curves can only be defined in ambient dimension 2")
			return 0
		# rmk : the points need to be created here to be compatible with the triangulation, because polymake doesn't order the points in the same order as the rest of the code
		list_files = subprocess.run(["polymake","--script", os.path.join(self.local_path , "Triangulation_creation", "create_harnack_triangulation.pl"), str(self.degree), self.triang_file, self.all_points_file])
		triang = read_triang(self.triang_file, format = "polymake")
		write_triang(triang, self.triang_file, format = "topcom")
		if verbose == True :
			my_string = json.dumps(triang).replace(']', '}').replace('[', '{')
			print("Triangulation :")
			print(my_string)
		self.create_symmetries_file(verbose)
		self.create_current_points_indices_file(verbose)
		self.create_flips_file(force_recompute= True)
		self.create_chiro_file(force_recompute=True)
		self.create_random_signs_file(verbose)

		
	def random_convex_hull_initialization(self, verbose = True):
		"""Creates a random triangulation in self.dim and self.degree and all the associated files needed for a walk on the graph of triangulations
		
			The triangulation is created by projecting the lower convex hull in R^self.dim of the graph of a random function whose domain is the monomials in self.dim and self.degree
			(seen as points in Z^self.dim)
		
		"""
		# Rmk : thanks to the new format, we do not need to get rid of redundant monomials anymore
		print(f"Creating a random triangulation in dimension {self.dim} and degree {self.degree} and all associated files as the projection of the lower convex hull of a random function")
		n_coeffs = comb(self.degree+self.dim, self.dim)
		up_bound = n_coeffs*2
		low_bound = 0
		coeffs = np.array([np.random.uniform(low_bound,up_bound,[n_coeffs])])
		self.triangulation_from_coeffs(coeffs, verbose)
		# important that the points in all_points_file are created in the same way as in the triple loop above
		self.create_all_points_file(verbose)
		self.create_symmetries_file(verbose)
		self.create_current_points_indices_file(verbose)
		self.create_flips_file(force_recompute= True)
		self.create_chiro_file(force_recompute=True)
		self.create_random_signs_file(verbose)

	def triangulation_from_coeffs(self, coeffs, verbose = True):
		"""Creates a triangulation by projecting the lower convex hull in R^self.dim of the graph of a vector of coeffs seen as a function whose domain is the monomials in self.dim and self.degree
			(seen as points in Z^self.dim) and stores it in triang_file
			
			coeffs must be of length comb(self.degree+self.dim, self.dim)
			"""
		monomials_temp_file = os.path.join(self.local_path, self.current_point_folder, "temp_monomials.dat")
		coeffs_temp_file = os.path.join(self.local_path, self.current_point_folder, "temp_coeffs.dat")
		# lists all homogeneous monomials (5 0 0, 3 1 1, etc.)
		# starts with non-homogeneous monomials
		vertices = [[0]*self.dim]
		for dim_considered in range(self.dim):
			new_vertices = []
			for vertex in vertices:
				for t in range(1,self.degree-sum(vertex)+1):
					new_vertex = copy.copy(vertex)
					new_vertex[dim_considered] = t
					if self.degree-sum(new_vertex)>=0:
						new_vertices += [new_vertex]
			vertices+=new_vertices
		# homogenize them with the first coordinate : 4 0 -> 1 4 0 (for degree 5)
		for index, vertex in enumerate(vertices) :
			vertices[index] = [self.degree - sum(vertex)] + vertex 
		with open(monomials_temp_file,"w") as t:
			np.savetxt(t,np.array(vertices),fmt='%d')
		# give coefficients to the monomials
		with open(coeffs_temp_file, 'w') as f:
			np.savetxt(f,coeffs,fmt='%1.4f')
		# compute the triangulation
		list_files = subprocess.run(["polymake","--script", os.path.join(self.local_path , "Triangulation_creation", "CRT_compute_triangulation.pl"),\
			self.triang_file, monomials_temp_file, coeffs_temp_file])
		triang = read_triang(self.triang_file, format = "polymake")
		write_triang(triang, self.triang_file, format = "topcom")
		os.remove(monomials_temp_file)
		os.remove(coeffs_temp_file)
		if verbose == True :
			my_string = json.dumps(triang).replace(']', '}').replace('[', '{')
			print("Triangulation :")
			print(my_string)

	def complete_current_point(self, force_recompute = False, verbose = False):
		"""Complete the list of files using those that already exist (assuming that we are considering a standard simplex in self.dim and self.degree)
		
			triang_file is strictly necessary, everything else can be recovered from there

			if force_recompute is True, everything gets recomputed using self.triang
		"""
		print("Completing the Current_Point files")
		if force_recompute:
			self.create_all_points_file(verbose)
			self.create_symmetries_file(verbose)
			self.create_current_points_indices_file(verbose)
			self.create_flips_file(force_recompute= True)
			self.create_chiro_file(force_recompute=True)
			self.create_random_signs_file(verbose)
		else : 
			# the order is important
			if not os.path.exists(self.all_points_file) :
				self.create_all_points_file(verbose)
			if not os.path.exists(self.symmetries_file) :
				self.create_symmetries_file(verbose)
			if not os.path.exists(self.current_points_indices_file) :
				self.create_current_points_indices_file(verbose)
			if not os.path.exists(self.flips_file) :
				self.create_flips_file()
			if not os.path.exists(self.chiro_file) :
				self.create_chiro_file()
			if not os.path.exists(self.signs_file) :
				self.create_random_signs_file(verbose)


	def complete_current_point_for_signs_optimization(self, verbose):
		""" Completes the following list of files (assuming that we are considering a standard simplex in self.dim and self.degree) :
			triang_file, signs_file, all_points_file, current_points_indices_file
			
			Those are the files needed for signs optimization (with fixed triangulation)

			triang_file at least must already exist
		
		"""
		if not os.path.exists(self.all_points_file) :
			self.create_all_points_file(verbose)
		if not os.path.exists(self.current_points_indices_file) :
			self.create_current_points_indices_file(verbose)
		if not os.path.exists(self.signs_file) :
			self.create_random_signs_file(verbose)


	def copy_from_other_current_point(self, other_current_point):
		"""Copies all the files from other_current_point into similarly named files in self.current_point_folder"""
		for key in other_current_point.list_of_files_names.keys():
			if os.path.exists(other_current_point.list_of_files_names[key]) :
				with open(other_current_point.list_of_files_names[key], 'r') as f:
					with open(self.list_of_files_names[key], 'w') as g:
						g.write(f.read())

	def copy_into_other_current_point(self, folder_of_new_current_point):
		"""Copies all the files in similarly named files in folder_of_new_current_point and returns a corresponding new Current_Point """
		new_current_point = Current_Point(self.dim, self.degree, self.local_path, folder_of_new_current_point)
		for key in self.list_of_files_names.keys():
			if os.path.exists(self.list_of_files_names[key]) :
				with open(self.list_of_files_names[key], 'r') as f:
					with open(new_current_point.list_of_files_names[key], 'w') as g:
						g.write(f.read())
		return new_current_point
	

	def compute_own_homology(self):
		"""Computes the homology of the current configuration (assuming the required files exist)"""
		temp_homology_file = os.path.join(self.local_path, self.current_point_folder, "temp_homology_file.txt")
		homology_profiles = compute_homology(self.local_path, self.current_point_folder, self.signs_file, self.triang_file, self.all_points_file, \
	 			temp_homology_file)
		os.remove(temp_homology_file)
		return homology_profiles[0]

	def visualize_hypersurface(self) :
		""" Shows the current hypersurface (assuming the required files exist)

			Required files : triang_file, signs_file, all_points_file
		
			self.dim must be 2 or 3
		"""

		purified_triang_temp_file = os.path.join(self.local_path, self.current_point_folder,'temp_purified_triang.dat')
		relevant_points_temp_file = os.path.join(self.local_path, self.current_point_folder,'temp_relevant_points.dat')
		relevant_monomials_temp_file = os.path.join(self.local_path, self.current_point_folder,'temp_relevant_monomials.dat')

		purify_points(self.triang_file,self.all_points_file, relevant_points_temp_file)
		purify_triang(self.triang_file, purified_triang_temp_file)
		points2monomials(relevant_points_temp_file,relevant_monomials_temp_file)

		list_files = subprocess.run(["polymake","--script",  os.path.join(self.local_path, "Visualization","visualize_hypersurface_perl.pl"),\
		self.local_path, purified_triang_temp_file, relevant_points_temp_file,relevant_monomials_temp_file, self.signs_file])

		os.remove(purified_triang_temp_file)
		os.remove(relevant_points_temp_file)
		os.remove(relevant_monomials_temp_file)

	def visualize_triangulation(self) :
		""" Shows the current triangulation (assuming the required files exist)
		
			Required filed : triang_file, all_points_file
			self.dim must be 2
		"""
		points = []
		with open(self.all_points_file,"r") as f:
			for line in f:
				point = [int(coordinate) for coordinate in line[4:].split()]
				points.append(point)
		points = np.array(points)
		triang = read_triang(self.triang_file, "topcom")
		plt.triplot(points[:,0], points[:,1],triang)
		plt.show()
